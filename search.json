[{"path":"https://littlebeannie.github.io/gsDesign2_key_functions_inner_logic/articles/usage-ahr.html","id":"introduction-of-ahr","dir":"Articles","previous_headings":"","what":"Introduction of ahr()","title":"ahr: computes AHR under NPH assumptions and (stratified) populations","text":"ahr() provides geometric average hazard ratio various non-proportional hazards assumptions either single multiple strata studies. piecewise exponential distribution allows simple method specify distribution enrollment pattern enrollment, failure dropout rates changes time.","code":""},{"path":[]},{"path":"https://littlebeannie.github.io/gsDesign2_key_functions_inner_logic/articles/usage-ahr.html","id":"example-1-un-stratified-population","dir":"Articles","previous_headings":"Usage of ahr()","what":"Example 1: Un-stratified population","title":"ahr: computes AHR under NPH assumptions and (stratified) populations","text":"","code":"enroll_rate <- define_enroll_rate(   duration = c(2, 10, 4, 4, 8),   rate = c(5, 10, 0, 3, 6) ) fail_rate <- define_fail_rate(   duration = 1,   fail_rate = c(.1, .2, .3, .4),   hr = c(.9, .75, .8, .6),   dropout_rate = .001 ) ahr(   enroll_rate = enroll_rate,   fail_rate = fail_rate,   total_duration = c(15, 30) ) %>% gt::gt()"},{"path":"https://littlebeannie.github.io/gsDesign2_key_functions_inner_logic/articles/usage-ahr.html","id":"example-2-stratified-population","dir":"Articles","previous_headings":"Usage of ahr()","what":"Example 2: Stratified population","title":"ahr: computes AHR under NPH assumptions and (stratified) populations","text":"","code":"enroll_rate <- define_enroll_rate(   stratum = c(rep(\"Low\", 2), rep(\"High\", 3)),   duration = c(2, 10, 4, 4, 8),   rate = c(5, 10, 0, 3, 6) ) fail_rate <- define_fail_rate(   stratum = c(rep(\"Low\", 2), rep(\"High\", 2)),   duration = 1,   fail_rate = c(.1, .2, .3, .4),   hr = c(.9, .75, .8, .6),   dropout_rate = .001 ) ahr(   enroll_rate = enroll_rate,   fail_rate = fail_rate,   total_duration = c(15, 30) ) %>% gt::gt()"},{"path":"https://littlebeannie.github.io/gsDesign2_key_functions_inner_logic/articles/usage-ahr.html","id":"inner-logic-of-ahr","dir":"Articles","previous_headings":"","what":"Inner Logic of ahr()","title":"ahr: computes AHR under NPH assumptions and (stratified) populations","text":"Let’s take un-stratified population example, enrollment rate, failure rates dropout rates Step 1: compute proportion group compute expected events different treatment group, stratum time period, iterate total_duration Strata. Since example, one analysis time (total_duration = 30) one stratum (stratum = \"\"), iterate . one multiple analysis time strata, one can use loop bind results row. Step 2: subset enrollment rates failure rates stratum. Step 3: calculate enrollment rates experimental arm control arm, respectively. Step 4: update failure rate control experimental arm. Step 5: calculate expected number events control experimental eEvents_df(). t column start period, fail_rate column failure rate period, Events column expected events period. Step 6: combine results together output . Please note , output, info column based following input. alternative hypothesis \\(H_1\\) \\[   \\text{hr}   =   \\left\\{   \\begin{array}{ll}     0.9  & \\text{first 1 month} \\\\     0.75 & \\text{afterwards},   \\end{array}   \\right. \\] info = info1, info1 statistical information \\(H_1\\). notice enroll_rate fail_rate always \\(H_1\\), call info, rather info1.","code":"enroll_rate <- define_enroll_rate(   duration = c(2, 10, 4),   rate = c(5, 10, 0) ) fail_rate <- define_fail_rate(   duration = 1,   fail_rate = c(.1, .2),   hr = c(.9, .75),   dropout_rate = .001 )  ratio <- 2  total_duration <- 30 q_e <- ratio / (1 + ratio) q_c <- 1 - q_e ## The proportion of the experimental arm is  0.6666667 ## The proportion of the control arm is  0.3333333 td <- total_duration s <- \"All\" enroll <- enroll_rate %>% filter(stratum == s) fail <- fail_rate %>% filter(stratum == s) enroll_c <- enroll %>% mutate(rate = rate * q_c) enroll_e <- enroll %>% mutate(rate = rate * q_e) fail_c <- fail fail_e <- fail %>% mutate(fail_rate = fail_rate * hr) events_c <- expected_event(   enroll_rate = enroll_c,   fail_rate = fail_c,   total_duration = td,   simple = FALSE ) events_e <- expected_event(   enroll_rate = enroll_e,   fail_rate = fail_e,   total_duration = td,   simple = FALSE ) ## The expected number of events in the control arm is ##   t fail_rate     event ## 1 0       0.1  3.487580 ## 2 1       0.2 30.561460 ## 3 2       0.2  1.983171 ## The expected number of events in the experimental arm is ##   t fail_rate     event ## 1 0      0.09  6.308606 ## 2 1      0.15 57.170622 ## 3 2      0.15  6.857246 # combine control and experimental events <- rbind(   events_c %>% mutate(Treatment = \"Control\"),   events_e %>% mutate(Treatment = \"Experimental\") ) %>%   arrange(t, Treatment) %>%   ungroup() %>%   # recompute HR, events, info by period   group_by(t) %>%   summarize(     stratum = s,     info = (sum(1 / event))^(-1),     Events = sum(event),     HR = last(fail_rate) / first(fail_rate)   ) %>%   # compute info0   mutate(     Time = td,     lnhr = log(HR),     info0 = Events * q_c * q_e   ) %>%   ungroup() %>%   group_by(Time, stratum, HR) %>%   summarize(     t = min(t),     Events = sum(Events),     info0 = sum(info0),     info = sum(info)   ) %>%   # pool time period together   group_by(Time) %>%   summarize(     AHR = exp(sum(log(HR) * Events) / sum(Events)),     Events = sum(Events),     info = sum(info),     info0 = sum(info0)   ) ## The overall expected number of events over the time is ## # A tibble: 1 × 5 ##    Time   AHR Events  info info0 ##   <dbl> <dbl>  <dbl> <dbl> <dbl> ## 1    30 0.763   106.  23.7  23.6 enroll_rate <- define_enroll_rate(   duration = c(2, 10, 4),   rate = c(5, 10, 0) ) fail_rate <- define_fail_rate(   duration = 1,   fail_rate = c(.1, .2),   hr = c(.9, .75),   dropout_rate = .001 )"},{"path":[]},{"path":[]},{"path":"https://littlebeannie.github.io/gsDesign2_key_functions_inner_logic/articles/usage-expected-accrual.html","id":"example-1","dir":"Articles","previous_headings":"Use cases of expected_accrual()","what":"Example 1","title":"expected_accrual: computes the expected cumulative enrollment (accrual) given a set of piecewise constant enrollment rates and times","text":"enrollment first 3 months, exactly \\(3 \\times 5 = 15\\).","code":"expected_accrual(   time = 3,   enroll_rate = define_enroll_rate(duration = c(3, 3, 18), rate = c(5, 10, 20)) ) ## [1] 15"},{"path":"https://littlebeannie.github.io/gsDesign2_key_functions_inner_logic/articles/usage-expected-accrual.html","id":"example-2","dir":"Articles","previous_headings":"Use cases of expected_accrual()","what":"Example 2","title":"expected_accrual: computes the expected cumulative enrollment (accrual) given a set of piecewise constant enrollment rates and times","text":"enrollment first 6 months, exactly \\(3 \\times 5 + 3 \\times 10 = 45\\).","code":"expected_accrual(   time = 6,   enroll_rate = define_enroll_rate(duration = c(3, 3, 18), rate = c(5, 10, 20)) ) ## [1] 45"},{"path":"https://littlebeannie.github.io/gsDesign2_key_functions_inner_logic/articles/usage-expected-accrual.html","id":"example-3","dir":"Articles","previous_headings":"Use cases of expected_accrual()","what":"Example 3","title":"expected_accrual: computes the expected cumulative enrollment (accrual) given a set of piecewise constant enrollment rates and times","text":"enrollment first 24 months, exactly \\(3 \\times 5 + 3 \\times 10 + 18 * 20 = 405\\).","code":"expected_accrual(   time = 24,   enroll_rate = define_enroll_rate(duration = c(3, 3, 18), rate = c(5, 10, 20)) ) ## [1] 405"},{"path":"https://littlebeannie.github.io/gsDesign2_key_functions_inner_logic/articles/usage-expected-accrual.html","id":"example-4","dir":"Articles","previous_headings":"Use cases of expected_accrual()","what":"Example 4","title":"expected_accrual: computes the expected cumulative enrollment (accrual) given a set of piecewise constant enrollment rates and times","text":"enrollment 24 months, 24 months, since enrollment stopped.","code":"expected_accrual(   time = 25,   enroll_rate = define_enroll_rate(duration = c(3, 3, 18), rate = c(5, 10, 20)) ) ## [1] 405"},{"path":"https://littlebeannie.github.io/gsDesign2_key_functions_inner_logic/articles/usage-expected-accrual.html","id":"example-5","dir":"Articles","previous_headings":"Use cases of expected_accrual()","what":"Example 5","title":"expected_accrual: computes the expected cumulative enrollment (accrual) given a set of piecewise constant enrollment rates and times","text":"Instead compute enrolled subjects one time point one time point, can also compute .","code":"expected_accrual(   time = c(3, 6, 24, 25),   enroll_rate = define_enroll_rate(duration = c(3, 3, 18), rate = c(5, 10, 20)) ) ## [1]  15  45 405 405"},{"path":"https://littlebeannie.github.io/gsDesign2_key_functions_inner_logic/articles/usage-expected-accrual.html","id":"inner-logic-of-expected_accrual","dir":"Articles","previous_headings":"","what":"Inner Logic of expected_accrual()","title":"expected_accrual: computes the expected cumulative enrollment (accrual) given a set of piecewise constant enrollment rates and times","text":"TODO","code":""},{"path":"https://littlebeannie.github.io/gsDesign2_key_functions_inner_logic/articles/usage-expected-event.html","id":"introduction-of-expected_event","dir":"Articles","previous_headings":"","what":"Introduction of expected_event()","title":"expected_event: compute expected number of events at 1 time point","text":"expected_event() computes expected number events given analysis time strata assumption piecewise model: piecewise constant enrollment rates piecewise exponential failure rates piecewise censoring rates. piecewise exponential distribution allows simple method specify distribution enrollment pattern enrollment, failure dropout rates changes time. df expected_event() short data frame, since output data frame.","code":""},{"path":[]},{"path":"https://littlebeannie.github.io/gsDesign2_key_functions_inner_logic/articles/usage-expected-event.html","id":"example-1-single-enroll-single-fail-period","dir":"Articles","previous_headings":"Use Cases","what":"Example 1: Single Enroll + Single Fail Period","title":"expected_event: compute expected number of events at 1 time point","text":"","code":"enroll_rate <- define_enroll_rate(duration = 10, rate = 10) fail_rate <- define_fail_rate(duration = 100, fail_rate = log(2) / 6, dropout_rate = .01) total_duration <- 22  expected_event(   enroll_rate = enroll_rate,   fail_rate = fail_rate,   total_duration = total_duration,   simple = FALSE ) ##   t fail_rate    event ## 1 0 0.1155245 80.40974"},{"path":"https://littlebeannie.github.io/gsDesign2_key_functions_inner_logic/articles/usage-expected-event.html","id":"example-2-multiple-enroll-single-fail-period","dir":"Articles","previous_headings":"Use Cases","what":"Example 2: Multiple Enroll + Single Fail Period","title":"expected_event: compute expected number of events at 1 time point","text":"","code":"enroll_rate <- define_enroll_rate(duration = c(5, 5), rate = c(10, 20)) fail_rate <- define_fail_rate(duration = 100, fail_rate = log(2) / 6, dropout_rate = .01) total_duration <- 22  expected_event(   enroll_rate = enroll_rate,   fail_rate = fail_rate,   total_duration = total_duration,   simple = FALSE ) ##   t fail_rate    event ## 1 0 0.1155245 118.8484"},{"path":"https://littlebeannie.github.io/gsDesign2_key_functions_inner_logic/articles/usage-expected-event.html","id":"example-3-single-enroll-multiple-fail-period","dir":"Articles","previous_headings":"Use Cases","what":"Example 3: Single Enroll + Multiple Fail Period","title":"expected_event: compute expected number of events at 1 time point","text":"","code":"enroll_rate <- define_enroll_rate(duration = 10, rate = 10) fail_rate <- define_fail_rate(   duration = c(20, 80),   fail_rate = c(log(2) / 6, log(2) / 4),   dropout_rate = .01 ) total_duration <- 22  expected_event(   enroll_rate = enroll_rate,   fail_rate = fail_rate,   total_duration = total_duration,   simple = FALSE ) ##    t fail_rate     event ## 1  0 0.1155245 80.236827 ## 2 20 0.1732868  0.250052"},{"path":"https://littlebeannie.github.io/gsDesign2_key_functions_inner_logic/articles/usage-expected-event.html","id":"inner-logic-of-expected_event","dir":"Articles","previous_headings":"","what":"Inner Logic of expected_event()","title":"expected_event: compute expected number of events at 1 time point","text":"Step 1: set analysis time. Step 2: set enrollment rates.  Step 3: set failure rates dropout rates.   Given piecewise enrollment rates, failure rates, dropout rates, time line divided several parts: \\((0, 5]\\) (5 change point enrollment rates); \\((5, 10]\\) (10 another change point enrollment rates); \\((10, 20]\\) (20 change point failure rates); \\((20, 50]\\) (50 analysis time); \\((50, \\infty]\\) (analysis time).  Given sub-intervals, objective calculate expected number events sub-intervals. Step 4: divide time line enrollments Step 5: divide time line failure & dropout rates df_2, one needs discriminate analysis time (total_duration = 50) beyond total failure rate duration. Step 6: divide time line considering change points enrollment, failure, dropout rates. find lots NA, can imputed piecewise model. Step 7: compute expected number events sub-intervals following technical details vignette computing expected events interval risk. Step 8: output results","code":"total_duration <- 50 enroll_rate <- define_enroll_rate(duration = c(5, 5), rate = c(10, 20))  # create a step function (sf) to define enrollment rates over time sf_enroll_rate <- stepfun(c(0, cumsum(enroll_rate$duration)),   c(0, enroll_rate$rate, 0),   right = FALSE )  plot(sf_enroll_rate,   xlab = \"duration\", ylab = \"enrollment rates\",   main = \"Piecewise enrollment rate over time\", xlim = c(-0.01, 21) ) fail_rate <- define_fail_rate(   duration = c(20, 80),   fail_rate = c(0.1, 0.2),   dropout_rate = .01 )  # get the time points where the failure rates change time_start_fail <- c(0, cumsum(fail_rate$duration))  # plot the piecewise failure rates sf_fail_rate <- stepfun(time_start_fail,   c(0, fail_rate$fail_rate, last(fail_rate$fail_rate)),   right = FALSE ) plot(sf_fail_rate,   xlab = \"duration\", ylab = \"failure rates\",   main = \"Piecewise failure rate over time\", xlim = c(-0.01, 101) ) # plot the piecewise dropout rate sf_dropout_rate <- stepfun(time_start_fail,   c(0, fail_rate$dropout_rate, last(fail_rate$dropout_rate)),   right = FALSE ) plot(sf_dropout_rate,   xlab = \"duration\", ylab = \"dropout rates\",   main = \"Piecewise dropout rate over time\", xlim = c(-0.01, 101) ) df_1 <- tibble(   startEnroll = c(0, cumsum(enroll_rate$duration)),   endFail = total_duration - startEnroll,   rate = c(enroll_rate$rate, 0) ) df_2 <- tibble(   endFail = cumsum(fail_rate$duration),   startEnroll = total_duration - endFail,   failRate = fail_rate$fail_rate,   dropoutRate = fail_rate$dropout_rate ) # if the analysis time is after the total failure rate duration if (sum(fail_rate$duration) < total_duration) {   df_2 <- df_2[-nrow(df_2), ] } else {   df_2 <- df_2 %>% filter(startEnroll > 0) } df <- full_join(df_1, df_2, by = c(\"startEnroll\", \"endFail\")) %>% arrange(endFail) df <- df %>%   mutate(     endEnroll = lag(startEnroll, default = as.numeric(total_duration)),     time_start_fail = lag(endFail, default = 0),     duration = endEnroll - startEnroll,     failRate = sf_fail_rate(time_start_fail),     dropoutRate = sf_dropout_rate(time_start_fail),     enrollRate = sf_enroll_rate(startEnroll)   ) %>%   select(-rate) # Create 2 auxiliary variables for failure & dropout rate # q: number of expected events in a sub-interval # Q: cumulative product of q (pool all sub-intervals) df <- df %>%   mutate(     q = exp(-duration * (failRate + dropoutRate)),     Q = lag(cumprod(q), default = 1)   ) %>%   arrange(desc(time_start_fail)) %>%   # Create another 2 auxiliary variables for enroll rate   # g: number of expected subjects in a sub-interval   # G: cumulative sum of g (pool all sub-intervals)   mutate(     g = enrollRate * duration,     G = lag(cumsum(g), default = 0)   ) %>%   arrange(time_start_fail) %>%   # Compute expected events as nbar in a sub-interval   mutate(     d = ifelse(       failRate == 0,       0,       Q * (1 - q) * failRate / (failRate + dropoutRate)     ),     nbar = ifelse(       failRate == 0,       0,       G * d + (failRate * Q * enrollRate) / (failRate + dropoutRate) * (duration - (1 - q) / (failRate + dropoutRate))     )   ) sf_time_start_fail <- stepfun(time_start_fail, c(0, time_start_fail), right = FALSE) df <- df %>%   transmute(t = endFail, failRate = failRate, Events = nbar, time_start_fail = sf_time_start_fail(time_start_fail)) %>%   group_by(time_start_fail) %>%   summarize(failRate = first(failRate), Events = sum(Events)) %>%   mutate(t = time_start_fail) %>%   select(\"t\", \"failRate\", \"Events\")  df %>% gt()"},{"path":"https://littlebeannie.github.io/gsDesign2_key_functions_inner_logic/articles/usage-expected-time.html","id":"introduction-of-expected_time","dir":"Articles","previous_headings":"","what":"Introduction of expected_time","title":"expected_time: compute time when a targeted number of events is made","text":"expected_time() predicts time targeted events made. designed twins AHR(): matches input/output format AHR().","code":""},{"path":[]},{"path":"https://littlebeannie.github.io/gsDesign2_key_functions_inner_logic/articles/usage-expected-time.html","id":"example-1","dir":"Articles","previous_headings":"Use Cases","what":"Example 1","title":"expected_time: compute time when a targeted number of events is made","text":"","code":"enroll_rate <- define_enroll_rate(   duration = c(2, 2, 10),   rate = c(3, 6, 9) * 5 ) fail_rate <- define_fail_rate(   duration = c(3, 100),   fail_rate = log(2) / c(9, 18), hr = c(.9, .6),   dropout_rate = rep(.001, 2) ) ratio <- 1  x <- expected_time(   enroll_rate = enroll_rate, fail_rate = fail_rate,   ratio = ratio, target_event = 200 )  x %>% gt()"},{"path":"https://littlebeannie.github.io/gsDesign2_key_functions_inner_logic/articles/usage-expected-time.html","id":"example-2","dir":"Articles","previous_headings":"Use Cases","what":"Example 2","title":"expected_time: compute time when a targeted number of events is made","text":"example, verify expected_time() AHR().","code":"enroll_rate <- define_enroll_rate(   duration = c(2, 2, 10),   rate = c(3, 6, 9) * 5 ) fail_rate <- define_fail_rate(   duration = c(3, 100),   fail_rate = log(2) / c(9, 18),   hr = c(.9, .6),   dropout_rate = rep(.001, 2) ) ratio <- 1  x <- ahr(   enroll_rate = enroll_rate, fail_rate = fail_rate,   ratio = ratio, total_duration = 20 ) cat(\"The number of events by 20 months is \", x$event, \".\\n\") ## The number of events by 20 months is  208.3641 . y <- expected_time(   enroll_rate = enroll_rate, fail_rate = fail_rate,   ratio = ratio, target_event = x$event )  cat(\"The time to get \", x$event, \" is \", y$time, \"months.\\n\") ## The time to get  208.3641  is  20 months."},{"path":"https://littlebeannie.github.io/gsDesign2_key_functions_inner_logic/articles/usage-expected-time.html","id":"inner-logic-of-expected_time","dir":"Articles","previous_headings":"","what":"Inner Logic of expected_time()","title":"expected_time: compute time when a targeted number of events is made","text":"inner logic expected_time() uniroot AHR() total_duration. Step 1: find difference AHR() different values total_duration. Step 2: uniroot AHR() total_duration.","code":"foo <- function(x) {   ans <- ahr(     enroll_rate = enroll_rate, fail_rate = fail_rate,     total_duration = x, ratio = ratio   )$event - target_event   return(ans) } enroll_rate <- define_enroll_rate(   duration = c(2, 2, 10),   rate = c(3, 6, 9) * 5 ) fail_rate <- define_fail_rate(   duration = c(3, 100),   fail_rate = log(2) / c(9, 18),   hr = c(.9, .6),   dropout_rate = .001 ) ratio <- 1 target_event <- 200  cat(\"The difference between `targetEvents = 200` and the events after 30 months is \", foo(30), \".\\n\") ## The difference between `targetEvents = 200` and the events after 30 months is  92.45484 . res <- uniroot(foo, interval = c(0.01, 100))  ans <- ahr(   enroll_rate = enroll_rate, fail_rate = fail_rate,   total_duration = res$root, ratio = ratio ) cat(\"After \", ans$time, \" months, there will be \", target_event, \" events .\\n\") ## After  19.16437  months, there will be  200  events ."},{"path":"https://littlebeannie.github.io/gsDesign2_key_functions_inner_logic/articles/usage-fixed-design.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"fixed_design_*: compute sample size/power of a fixed design","text":"vignette, introduce key functionality fixed_design_xxx() gsDesign2. Generally speaking, fixed_design_xxx() capable power calculations sample size calculations many methods, including fixed_design_ahr(): AHR fixed_design_fh()Fleming-Harrington (FH) (farrington1990test?) fixed_design_mb()Magirr-Burman (MB) fixed_design_lf()Lachin-Foulkes (LF) (lachin1986evaluation?) fixed_design_rmst()RMST (yung2020sample?) fixed_design_milestone()Milestone (yung2020sample?) fixed_design_rd()Risk difference (RD) (mehrotra2000minimum?). Throughout vignette, assume design parameter ","code":"# Enrollment rate enroll_rate <- define_enroll_rate(   duration = 18,   rate = 20 )  # Failure rates fail_rate <- define_fail_rate(   duration = c(4, 100),   fail_rate = log(2) / 12,   hr = c(1, .6),   dropout_rate = .001 )  # Study duration in months study_duration <- 36  # Experimental / Control randomization ratio ratio <- 1  # 1-sided Type I error alpha <- 0.025 # Type II error (1 - power) beta <- 0.1"},{"path":"https://littlebeannie.github.io/gsDesign2_key_functions_inner_logic/articles/usage-fixed-design.html","id":"examples-of-ahr","dir":"Articles","previous_headings":"","what":"Examples of AHR","title":"fixed_design_*: compute sample size/power of a fixed design","text":"one wants get power 90%, one can calculate sample size Given enrollment rate enrollment duration, one can calculate power AHR ","code":"fixed_design_ahr(   alpha = alpha,   power = 1 - beta,   enroll_rate = enroll_rate,   fail_rate = fail_rate,   study_duration = study_duration,   ratio = ratio ) %>%   summary() %>%   as_gt() fixed_design_ahr(   alpha = alpha,   enroll_rate = enroll_rate,   fail_rate = fail_rate,   study_duration = study_duration,   ratio = ratio ) %>%   summary() %>%   as_gt()"},{"path":"https://littlebeannie.github.io/gsDesign2_key_functions_inner_logic/articles/usage-fixed-design.html","id":"examples-of-fh","dir":"Articles","previous_headings":"","what":"Examples of FH","title":"fixed_design_*: compute sample size/power of a fixed design","text":"one wants get power 90%, one can calculate sample size example, FH parameters (rho, gamma) take default value rho = 0, gamma = 0.5. users can always custom rho gamma Given enrollment rate enrollment duration, one can calculate power FH default rho, gamma users can always custom rho gamma ","code":"# Fixed design with a given power with default rho/gamma fixed_design_fh(   alpha = alpha,   power = 1 - beta,   enroll_rate = enroll_rate,   fail_rate = fail_rate,   study_duration = study_duration,   ratio = ratio ) %>%   summary() %>%   as_gt() # Fixed design with a given power with input rho/gamma fixed_design_fh(   alpha = alpha,   power = 1 - beta,   enroll_rate = enroll_rate,   fail_rate = fail_rate,   study_duration = study_duration,   ratio = ratio,   rho = 0.5,   gamma = 0.5 ) %>%   summary() %>%   as_gt() # Fixed design with power calculated fixed_design_fh(   alpha = alpha,   enroll_rate = enroll_rate,   fail_rate = fail_rate,   study_duration = study_duration,   ratio = ratio ) %>%   summary() %>%   as_gt() # Fixed design with power calculated fixed_design_fh(   alpha = alpha,   enroll_rate = enroll_rate,   fail_rate = fail_rate,   study_duration = study_duration,   ratio = ratio,   rho = 0.5, gamma = 0.5 ) %>%   summary() %>%   as_gt()"},{"path":"https://littlebeannie.github.io/gsDesign2_key_functions_inner_logic/articles/usage-fixed-design.html","id":"examples-of-mb","dir":"Articles","previous_headings":"","what":"Examples of mb","title":"fixed_design_*: compute sample size/power of a fixed design","text":"one wants get power 90%, one can calculate sample size example, mb parameter (tau) takes default value tau = 6. users can always custom tau Given enrollment rate enrollment duration, one can calculate power MB default tau = 6 users can always custom tau ","code":"fixed_design_mb(   ratio = ratio,   alpha = alpha,   power = 1 - beta,   enroll_rate = enroll_rate,   fail_rate = fail_rate,   study_duration = study_duration ) %>%   summary() %>%   as_gt() fixed_design_mb(   ratio = ratio,   alpha = alpha,   power = 1 - beta,   enroll_rate = enroll_rate,   fail_rate = fail_rate,   study_duration = study_duration,   tau = 4 ) %>%   summary() %>%   as_gt() fixed_design_mb(   ratio = ratio,   alpha = alpha,   enroll_rate = enroll_rate,   fail_rate = fail_rate,   study_duration = study_duration ) %>%   summary() %>%   as_gt() fixed_design_mb(   ratio = ratio,   alpha = alpha,   enroll_rate = enroll_rate,   fail_rate = fail_rate,   study_duration = study_duration,   tau = 4 ) %>%   summary() %>%   as_gt()"},{"path":"https://littlebeannie.github.io/gsDesign2_key_functions_inner_logic/articles/usage-fixed-design.html","id":"examples-of-lf","dir":"Articles","previous_headings":"","what":"Examples of lf","title":"fixed_design_*: compute sample size/power of a fixed design","text":"one wants get power 90%, one can calculate sample size Given enrollment rate enrollment duration, one can calculate power LF ","code":"fixed_design_lf(   alpha = alpha,   power = 1 - beta,   ratio = ratio,   enroll_rate = enroll_rate,   fail_rate = fail_rate,   study_duration = study_duration ) %>%   summary() %>%   as_gt() fixed_design_lf(   alpha = alpha,   ratio = ratio,   enroll_rate = enroll_rate,   fail_rate = fail_rate,   study_duration = study_duration ) %>%   summary() %>%   as_gt()"},{"path":"https://littlebeannie.github.io/gsDesign2_key_functions_inner_logic/articles/usage-fixed-design.html","id":"examples-of-maxcombo","dir":"Articles","previous_headings":"","what":"Examples of MaxCombo","title":"fixed_design_*: compute sample size/power of a fixed design","text":"one wants get power 90%, one can calculate sample size example, MaxCombo parameters take default value users can always custom rho, gamma, tau Given enrollment rate enrollment duration, one can calculate power MaxCombo default parameters users can always custom rho, gamma, tau ","code":"fixed_design_maxcombo(   alpha = alpha,   power = 1 - beta,   ratio = ratio,   enroll_rate = enroll_rate,   fail_rate = fail_rate,   study_duration = study_duration ) %>%   summary() %>%   as_gt() data.frame(rho = c(0, 0), gamma = c(0, 0.5), tau = -1) %>% gt() fixed_design_maxcombo(   alpha = alpha,   power = 1 - beta,   ratio = ratio,   enroll_rate = enroll_rate,   fail_rate = fail_rate,   study_duration = study_duration,   rho = c(0, 0.5, 0.5),   gamma = c(0, 0, 0.5),   tau = c(-1, 4, 6) ) %>%   summary() %>%   as_gt() fixed_design_maxcombo(   alpha = alpha,   ratio = ratio,   enroll_rate = enroll_rate,   fail_rate = fail_rate,   study_duration = study_duration ) %>%   summary() %>%   as_gt() fixed_design_maxcombo(   alpha = alpha,   ratio = ratio,   enroll_rate = enroll_rate,   fail_rate = fail_rate,   study_duration = study_duration,   rho = c(0, 0.5, 0.5),   gamma = c(0, 0, 0.5),   tau = c(-1, 4, 6) ) %>%   summary() %>%   as_gt()"},{"path":"https://littlebeannie.github.io/gsDesign2_key_functions_inner_logic/articles/usage-fixed-design.html","id":"examples-of-rmst","dir":"Articles","previous_headings":"","what":"Examples of RMST","title":"fixed_design_*: compute sample size/power of a fixed design","text":"one wants get power 90%, one can calculate sample size Given enrollment rate enrollment duration, one can calculate power RMST ","code":"fixed_design_rmst(   alpha = alpha,   power = 1 - beta,   enroll_rate = enroll_rate,   fail_rate = fail_rate,   study_duration = study_duration,   ratio = ratio,   tau = 18 ) %>%   summary() %>%   as_gt() fixed_design_rmst(   alpha = alpha,   enroll_rate = enroll_rate,   fail_rate = fail_rate,   study_duration = study_duration,   ratio = ratio,   tau = 18 ) %>%   summary() %>%   as_gt()"},{"path":"https://littlebeannie.github.io/gsDesign2_key_functions_inner_logic/articles/usage-fixed-design.html","id":"examples-of-milestone","dir":"Articles","previous_headings":"","what":"Examples of Milestone","title":"fixed_design_*: compute sample size/power of a fixed design","text":"one wants get power 90%, one can calculate sample size Given enrollment rate enrollment duration, one can calculate power Milestone ","code":"fixed_design_milestone(   alpha = alpha,   power = 1 - beta,   enroll_rate = enroll_rate,   fail_rate = fail_rate,   study_duration = study_duration,   ratio = ratio,   tau = 18 ) %>%   summary() %>%   as_gt() fixed_design_milestone(   alpha = alpha,   enroll_rate = enroll_rate,   fail_rate = fail_rate,   study_duration = study_duration,   ratio = ratio,   tau = 18 ) %>%   summary() %>%   as_gt()"},{"path":"https://littlebeannie.github.io/gsDesign2_key_functions_inner_logic/articles/usage-fixed-design.html","id":"examples-of-rd","dir":"Articles","previous_headings":"","what":"Examples of RD","title":"fixed_design_*: compute sample size/power of a fixed design","text":"one wants get power 90%, one can calculate sample size Given enrollment rate enrollment duration, one can calculate power ","code":"fixed_design_rd(   alpha = alpha,   power = 1 - beta,   p_c = .15,   p_e = .1,   rd0 = 0,   ratio = ratio ) %>%   summary() %>%   as_gt() fixed_design_rd(   alpha = alpha,   power = NULL,   p_c = .15,   p_e = .1,   rd0 = 0,   n = 2000,   ratio = ratio ) %>%   summary() %>%   as_gt()"},{"path":"https://littlebeannie.github.io/gsDesign2_key_functions_inner_logic/articles/usage-fixed-design.html","id":"examples-to-get-multiple-designs-together","dir":"Articles","previous_headings":"","what":"Examples to get multiple designs together","title":"fixed_design_*: compute sample size/power of a fixed design","text":"","code":"x_ahr <- fixed_design_ahr(   alpha = alpha,   ratio = ratio,   enroll_rate = enroll_rate,   fail_rate = fail_rate,   study_duration = study_duration )  x_fh <- fixed_design_fh(   alpha = alpha,   ratio = ratio,   enroll_rate = enroll_rate,   fail_rate = fail_rate,   study_duration = study_duration,   rho = 0.5,   gamma = 0.5 )  x_mb <- fixed_design_mb(   alpha = alpha,   ratio = ratio,   enroll_rate = enroll_rate,   fail_rate = fail_rate,   study_duration = study_duration,   tau = 4 )  x_lf <- fixed_design_lf(   alpha = alpha,   ratio = ratio,   enroll_rate = enroll_rate,   fail_rate = fail_rate,   study_duration = study_duration )  x_maxcombo <- fixed_design_maxcombo(   alpha = alpha,   ratio = ratio,   enroll_rate = enroll_rate,   fail_rate = fail_rate,   study_duration = study_duration,   rho = c(0, 0.5, 0.5),   gamma = c(0, 0, 0.5),   tau = c(-1, 4, 6) )  x_rmst <- fixed_design_rmst(   alpha = alpha,   ratio = ratio,   enroll_rate = enroll_rate,   fail_rate = fail_rate,   study_duration = study_duration,   tau = 30 )  x_milestone <- fixed_design_milestone(   alpha = alpha,   ratio = ratio,   enroll_rate = enroll_rate,   fail_rate = fail_rate,   study_duration = study_duration,   tau = 30 )  rbind(   summary(x_ahr), summary(x_fh),   summary(x_mb), summary(x_lf),   summary(x_maxcombo), summary(x_rmst),   summary(x_milestone) ) %>% gt()"},{"path":"https://littlebeannie.github.io/gsDesign2_key_functions_inner_logic/articles/usage-gs-b.html","id":"introduction-of-gs_b","dir":"Articles","previous_headings":"","what":"Introduction of gs_b()","title":"gs_b: specify fixed boundaries in group sequential designs","text":"gs_b() can used derive fixed boundary fixed/group sequential design. usually used upper = ... lower = ... arguments gs_power_npe() gs_design_npe() gs_power_ahr() gs_design_ahr() gs_power_wlr() gs_design_wlr() gs_power_combo() gs_design_combo()","code":""},{"path":[]},{"path":"https://littlebeannie.github.io/gsDesign2_key_functions_inner_logic/articles/usage-gs-b.html","id":"example-1","dir":"Articles","previous_headings":"Usage of gs_b()","what":"Example 1","title":"gs_b: specify fixed boundaries in group sequential designs","text":"Assume group sequential design 3 analysis, one can input upper bound vector c(4, 3, 2) using gs_b() follows.","code":"gs_b(par = 4:2) ## [1] 4 3 2"},{"path":"https://littlebeannie.github.io/gsDesign2_key_functions_inner_logic/articles/usage-gs-b.html","id":"example-2","dir":"Articles","previous_headings":"Usage of gs_b()","what":"Example 2","title":"gs_b: specify fixed boundaries in group sequential designs","text":"example, one can assign upper bound second analysis ","code":"gs_b(par = 4:2, k = 2) ## [1] 3"},{"path":"https://littlebeannie.github.io/gsDesign2_key_functions_inner_logic/articles/usage-gs-b.html","id":"example-3","dir":"Articles","previous_headings":"Usage of gs_b()","what":"Example 3","title":"gs_b: specify fixed boundaries in group sequential designs","text":"Generate efficacy bound using spending function. Use Lan-DeMets spending approximation O’Brien-Fleming bound 50%, 75% 100% final spending","code":"# information fraction info_frac <- c(.5, .75, 1) # Lan-DeMets spending approximation of O'Brien-Fleming par <- gsDesign::gsDesign(   alpha = .025, k = length(info_frac),   test.type = 1, sfu = gsDesign::sfLDOF,   timing = info_frac )$upper$bound gs_b(par = par) ## [1] 2.962588 2.359018 2.014084"},{"path":"https://littlebeannie.github.io/gsDesign2_key_functions_inner_logic/articles/usage-gs-b.html","id":"inner-logic-of-gs_b","dir":"Articles","previous_headings":"","what":"Inner Logic of gs_b()","title":"gs_b: specify fixed boundaries in group sequential designs","text":"gs_b() short function 2 key arguments: par = ... k = ...","code":"if (is.null(k)) {   return(par) } else {   return(par[k]) }"},{"path":"https://littlebeannie.github.io/gsDesign2_key_functions_inner_logic/articles/usage-gs-info-ahr.html","id":"introduction-of-gs_info_ahr","dir":"Articles","previous_headings":"","what":"Introduction of gs_info_ahr()","title":"gs_info_ahr: compute statistical information by the AHR method","text":"expected_time() calculate analysis time (Time output), number events (Events output), average hazard ratio (AHR outputs), effect size (theta output), statistical information (info info0 output) using average hazard ratio model. aforementioned calculation based piecewise model: piecewise constant enrollment rates piecewise exponential failure rates piecewise censoring rates.","code":""},{"path":[]},{"path":"https://littlebeannie.github.io/gsDesign2_key_functions_inner_logic/articles/usage-gs-info-ahr.html","id":"example-1","dir":"Articles","previous_headings":"Use Cases","what":"Example 1","title":"gs_info_ahr: compute statistical information by the AHR method","text":"example, input target number events event = ..., derive time events arrived.","code":"enroll_rate <- define_enroll_rate(   duration = c(2, 2, 10),   rate = c(3, 6, 9) * 5 ) fail_rate <- define_fail_rate(   duration = c(3, 100),   fail_rate = log(2) / c(9, 18),   hr = c(.9, .6),   dropout_rate = .001 ) ratio <- 1  gs_info_ahr(   enroll_rate = enroll_rate, fail_rate = fail_rate,   ratio = ratio, event = c(50, 80, 100) ) ##   analysis     time     event       ahr     theta     info    info0 ## 1        1  8.29028  49.99994 0.8496650 0.1629131 12.38312 12.49998 ## 2        2 10.53843  80.00004 0.8248912 0.1925038 19.74868 20.00001 ## 3        3 11.87087 100.00001 0.8119328 0.2083377 24.64666 25.00000"},{"path":"https://littlebeannie.github.io/gsDesign2_key_functions_inner_logic/articles/usage-gs-info-ahr.html","id":"example-2","dir":"Articles","previous_headings":"Use Cases","what":"Example 2","title":"gs_info_ahr: compute statistical information by the AHR method","text":"example, input analysis time analysis_time = ..., derive number events analysis time.","code":"enroll_rate <- define_enroll_rate(   duration = c(2, 2, 10),   rate = c(3, 6, 9) * 5 ) fail_rate <- define_fail_rate(   duration = c(3, 100),   fail_rate = log(2) / c(9, 18),   hr = c(.9, .6),   dropout_rate = .001 ) ratio <- 1  gs_info_ahr(   enroll_rate = enroll_rate, fail_rate = fail_rate,   ratio = ratio, analysis_time = c(10, 15, 20) ) ##   analysis time     event       ahr     theta     info    info0 ## 1        1   10  72.37787 0.8305350 0.1856853 17.87995 18.09447 ## 2        2   15 151.39207 0.7857415 0.2411275 37.20593 37.84802 ## 3        3   20 208.36411 0.7377944 0.3040901 50.97575 52.09103"},{"path":"https://littlebeannie.github.io/gsDesign2_key_functions_inner_logic/articles/usage-gs-info-ahr.html","id":"example-3","dir":"Articles","previous_headings":"Use Cases","what":"Example 3","title":"gs_info_ahr: compute statistical information by the AHR method","text":"example, input analysis_time = ... event = .... case, one see derived analysis time (time column) \\(\\geq\\) input analysis_time derived number event (Events column) \\(\\geq\\) input event","code":"enroll_rate <- define_enroll_rate(   duration = c(2, 2, 10),   rate = c(3, 6, 9) * 5 ) fail_rate <- define_fail_rate(   duration = c(3, 100),   fail_rate = log(2) / c(9, 18),   hr = c(.9, .6),   dropout_rate = .001 ) ratio <- 1  gs_info_ahr(   enroll_rate = enroll_rate, fail_rate = fail_rate,   ratio = ratio, analysis_time = c(10, 15, 20), event = c(     80, # > events in example 2     140, # < > events in example 2     220 # > events in example 2   ) ) ##   analysis     time     event       ahr     theta     info    info0 ## 1        1 10.53843  80.00004 0.8248912 0.1925038 19.74868 20.00001 ## 2        2 15.00000 151.39207 0.7857415 0.2411275 37.20593 37.84802 ## 3        3 21.20240 220.00000 0.7297710 0.3150245 53.80284 55.00000"},{"path":"https://littlebeannie.github.io/gsDesign2_key_functions_inner_logic/articles/usage-gs-info-ahr.html","id":"inner-logic-of-gs_info_ahr","dir":"Articles","previous_headings":"","what":"Inner Logic of gs_info_ahr()","title":"gs_info_ahr: compute statistical information by the AHR method","text":"explain inner logic gs_info_ahr(), discuss 3 scenario. input analysis_time input event input analysis_time event","code":""},{"path":"https://littlebeannie.github.io/gsDesign2_key_functions_inner_logic/articles/usage-gs-info-ahr.html","id":"scenario-1-only-input-analysis_time","dir":"Articles","previous_headings":"Inner Logic of gs_info_ahr()","what":"Scenario 1: only input analysis_time","title":"gs_info_ahr: compute statistical information by the AHR method","text":"analysis_time = ... input, essentially, gs_info_ahr() uses AHR() calculate number events analysis_time. exactly output gs_info_ahr():","code":"enroll_rate <- define_enroll_rate(   duration = c(2, 2, 10),   rate = c(3, 6, 9) * 5 ) fail_rate <- define_fail_rate(   duration = c(3, 100),   fail_rate = log(2) / c(9, 18),   hr = c(.9, .6),   dropout_rate = .001 ) ratio <- 1 analysis_time <- c(10, 15, 20)  ahr(   enroll_rate = enroll_rate, fail_rate = fail_rate,   ratio = ratio, total_duration = analysis_time ) %>%   mutate(theta = -log(ahr), Analysis = seq_along(analysis_time)) %>%   select(Analysis, time, event, ahr, theta, info, info0) %>%   gt() gs_info_ahr(   enroll_rate = enroll_rate, fail_rate = fail_rate,   ratio = ratio, analysis_time = analysis_time ) %>% gt()"},{"path":"https://littlebeannie.github.io/gsDesign2_key_functions_inner_logic/articles/usage-gs-info-ahr.html","id":"scenario-2-only-input-event","dir":"Articles","previous_headings":"Inner Logic of gs_info_ahr()","what":"Scenario 2: only input event","title":"gs_info_ahr: compute statistical information by the AHR method","text":"event = ... input, essentially, gs_info_ahr() uses expected_time() calculate time events arrived. exactly output gs_info_ahr():","code":"enroll_rate <- define_enroll_rate(   duration = c(2, 2, 10),   rate = c(3, 6, 9) * 5 ) fail_rate <- define_fail_rate(   duration = c(3, 100),   fail_rate = log(2) / c(9, 18),   hr = c(.9, .6),   dropout_rate = .001 ) ratio <- 1 events <- c(70, 150, 200)  ans <- NULL for (i in seq_along(events)) {   ans_new <- gsDesign2::expected_time(     enroll_rate = enroll_rate, fail_rate = fail_rate,     ratio = ratio, target_event = events[i]   )   ans <- rbind(ans, ans_new) }  ans %>%   mutate(theta = -log(ahr), Analysis = seq_along(analysis_time)) %>%   select(Analysis, time, event, ahr, theta, info, info0) %>%   gt() gs_info_ahr(   enroll_rate = enroll_rate, fail_rate = fail_rate,   ratio = ratio, event = events ) %>% gt()"},{"path":"https://littlebeannie.github.io/gsDesign2_key_functions_inner_logic/articles/usage-gs-info-ahr.html","id":"scenario-3-both-input-analysis_time-and-event","dir":"Articles","previous_headings":"Inner Logic of gs_info_ahr()","what":"Scenario 3: both input analysis_time and event","title":"gs_info_ahr: compute statistical information by the AHR method","text":"analysis_time = ... event = ... input, gs_info_ahr() uses AHR() expected_time(). way, guaranteed derived number event (event column) \\(\\geq\\) input event derived analysis time (time column) \\(\\geq\\) input analysis_time exactly output gs_info_ahr():","code":"enroll_rate <- define_enroll_rate(   duration = c(2, 2, 10),   rate = c(3, 6, 9) * 5 ) fail_rate <- define_fail_rate(   duration = c(3, 100),   fail_rate = log(2) / c(9, 18),   hr = c(.9, .6),   dropout_rate = .001 ) ratio <- 1 analysis_time <- c(10, 15, 20) events <- c(70, 150, 200)  ans <- NULL  # First, use `AHR()` to calculate the number of events at the input `analysis_time` ans <- ahr(   enroll_rate = enroll_rate, fail_rate = fail_rate,   ratio = ratio, total_duration = analysis_time )  # Second, compare if the events derived above meet the targeted number of events input in `events` for (i in seq_along(events)) {   if (ans$event[i] < events[i]) {     ans[i, ] <- expected_time(       enroll_rate = enroll_rate, fail_rate = fail_rate,       ratio = ratio, target_event = events[i]     )   } }  ans %>%   mutate(theta = -log(ahr), Analysis = seq_along(analysis_time)) %>%   select(Analysis, time, event, ahr, theta, info, info0) %>%   gt() gs_info_ahr(   enroll_rate = enroll_rate, fail_rate = fail_rate,   ratio = ratio, event = events, analysis_time = analysis_time ) %>% gt()"},{"path":"https://littlebeannie.github.io/gsDesign2_key_functions_inner_logic/articles/usage-gs-power-npe.html","id":"introduction-of-gs_power_npe","dir":"Articles","previous_headings":"","what":"Introduction of gs_power_npe()","title":"gs_power_npe: derives bounds and crossing probabilities for group sequential designs under NPH assumptions","text":"gs_power_npe() derives group sequential bounds boundary crossing probabilities design. allows non-constant treatment effect time, also can applied usual homogeneous effect size designs. requires treatment effect (theta, theta1) statistical information analysis (info, info0, info1) method deriving bounds, fixed bounds spending (upper, upar, lower, lpar). routine enables two things available gsDesign package: non-constant effect, flexibility boundary selection.","code":""},{"path":[]},{"path":[]},{"path":"https://littlebeannie.github.io/gsDesign2_key_functions_inner_logic/articles/usage-gs-power-npe.html","id":"no-futility-bound","dir":"Articles","previous_headings":"Usage of gs_power_npe() > Example 1: Fixed bound","what":"no futility bound","title":"gs_power_npe: derives bounds and crossing probabilities for group sequential designs under NPH assumptions","text":"","code":"# Same fixed efficacy bounds,  (i.e., non-binding bound), null hypothesis gs_power_npe(   theta = rep(0, 3),   info = (1:3) * 40,   upar = gsDesign::gsDesign(k = 3, sfu = gsDesign::sfLDOF)$upper$bound,   lpar = rep(-Inf, 3) ) %>%   filter(bound == \"upper\") %>%   gt()"},{"path":"https://littlebeannie.github.io/gsDesign2_key_functions_inner_logic/articles/usage-gs-power-npe.html","id":"with-futility-bound","dir":"Articles","previous_headings":"Usage of gs_power_npe() > Example 1: Fixed bound","what":"with futility bound","title":"gs_power_npe: derives bounds and crossing probabilities for group sequential designs under NPH assumptions","text":"","code":"# Fixed bound gs_power_npe(   theta = c(.1, .2, .3),   info = (1:3) * 40,   upper = gs_b,   upar = gsDesign::gsDesign(k = 3, sfu = gsDesign::sfLDOF)$upper$bound,   lower = gs_b,   lpar = c(-1, 0, 0) ) %>% gt()"},{"path":"https://littlebeannie.github.io/gsDesign2_key_functions_inner_logic/articles/usage-gs-power-npe.html","id":"futility-only-at-analysis-1","dir":"Articles","previous_headings":"Usage of gs_power_npe() > Example 1: Fixed bound","what":"futility only at analysis 1","title":"gs_power_npe: derives bounds and crossing probabilities for group sequential designs under NPH assumptions","text":"","code":"gs_power_npe(   theta = c(.1, .2, .3),   info = (1:3) * 40,   upper = gs_b,   upar = c(Inf, 3, 2),   lower = gs_b,   lpar = c(qnorm(.1), -Inf, -Inf) ) %>% gt()"},{"path":[]},{"path":"https://littlebeannie.github.io/gsDesign2_key_functions_inner_logic/articles/usage-gs-power-npe.html","id":"lower-spending-based-on-non-zero-effect","dir":"Articles","previous_headings":"Usage of gs_power_npe() > Example 2: spending bounds","what":"lower spending based on non-zero effect","title":"gs_power_npe: derives bounds and crossing probabilities for group sequential designs under NPH assumptions","text":"","code":"gs_power_npe(   theta = c(.1, .2, .3), # non-zero effect   info = (1:3) * 40,   upper = gs_spending_bound,   upar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL),   lower = gs_spending_bound,   lpar = list(sf = gsDesign::sfHSD, total_spend = 0.1, param = -1, timing = NULL) ) ## # A tibble: 6 × 10 ##   analysis bound       z probability theta theta1 info_frac  info info0 info1 ##      <int> <chr>   <dbl>       <dbl> <dbl>  <dbl>     <dbl> <dbl> <dbl> <dbl> ## 1        1 upper  3.71       0.00104   0.1    0.1     0.333    40    40    40 ## 2        2 upper  2.51       0.235     0.2    0.2     0.667    80    80    80 ## 3        3 upper  1.99       0.883     0.3    0.3     1       120   120   120 ## 4        1 lower -1.36       0.0230    0.1    0.1     0.333    40    40    40 ## 5        2 lower  0.0726     0.0552    0.2    0.2     0.667    80    80    80 ## 6        3 lower  1.86       0.100     0.3    0.3     1       120   120   120"},{"path":"https://littlebeannie.github.io/gsDesign2_key_functions_inner_logic/articles/usage-gs-power-npe.html","id":"sided-symmetric-spend","dir":"Articles","previous_headings":"Usage of gs_power_npe() > Example 2: spending bounds","what":"2-sided symmetric spend","title":"gs_power_npe: derives bounds and crossing probabilities for group sequential designs under NPH assumptions","text":"","code":"x <- gs_power_npe(   theta = rep(0, 3),   info = (1:3) * 40,   # typically, 2-sided bounds are binding   binding = TRUE,   upper = gs_spending_bound,   # O'Brien-Fleming spending   upar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL),   lower = gs_spending_bound,   lpar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL) )  x %>% gt() # Re-use these bounds under alternate hypothesis # Always use binding = TRUE for power calculations gs_power_npe(   theta = c(.1, .2, .3),   info = (1:3) * 40,   binding = TRUE,   upar = (x %>% filter(bound == \"upper\"))$z,   lpar = -(x %>% filter(bound == \"upper\"))$z ) %>%   gt()"},{"path":"https://littlebeannie.github.io/gsDesign2_key_functions_inner_logic/articles/usage-gs-power-npe.html","id":"inner-logic-of-gs_spending_bound","dir":"Articles","previous_headings":"","what":"Inner Logic of gs_spending_bound()","title":"gs_power_npe: derives bounds and crossing probabilities for group sequential designs under NPH assumptions","text":"TODO","code":""},{"path":"https://littlebeannie.github.io/gsDesign2_key_functions_inner_logic/articles/usage-gs-spending-bound.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Computing spending boundaries in group sequential design","text":"compare derivation different spending bounds using gsDesign2 gsDesign packages. gsDesign, 6 types bounds. demonstrate replicate using gsDesign2. gsDesign2, gs_spending_bound() function can used derive spending boundaries group sequential design derivations power calculations. demonstrate gs_design_ahr() function , using designs proportional hazards assumptions compare gsDesign::gsSurv(). Since sample size methods differ gsDesign2::gs_design_ahr() gsDesign::gsSurv() functions, use continuous sample sizes spending bounds (Z-values, nominal \\(p\\)-values, spending) identical except noted. Indeed, able reproduce bounds high degree accuracy. Due different sample size methods, sample size boundary approximations vary slightly. also present seventh example implement futility bound based observed hazard ratio well Haybittle-Peto-like efficacy bound. particular, futility bound difficult implement using gsDesign package straightforward using gsDesign2. last two examples, implement integer sample size event counts using to_integer() function gsDesign2 package toInteger() function gsDesign package. generally used cases comparing package computations Examples 1–5. examples, use following design assumptions: choice Type II error 0.15 corresponding 85% power intentional. allows impactful futility bounds interim analyses. Many teams may decide typical 90% power (beta = .1), can make futility bounds less likely impact early decisions.","code":"trial_duration <- 36 # Planned trial duration info_frac <- c(.35, .7, 1) # Information fraction at analyses # 16 month planned enrollment with constant rate enroll_rate <- define_enroll_rate(duration = 16, rate = 1) # Minimum follow-up for gsSurv() (computed) minfup <- trial_duration - sum(enroll_rate$duration) # Failure rates fail_rate <- define_fail_rate(   duration = Inf, # Single time period, exponential failure   fail_rate = log(2) / 12, # Exponential time-to-event with 12 month median   hr = .7, # Proportional hazards   dropout_rate = -log(.99) / 12 # 1% dropout rate per year ) alpha <- 0.025 # Type I error (one-sided) beta <- 0.15 # 85% power = 15% Type II error ratio <- 1 # Randomization ratio (experimental / control)"},{"path":"https://littlebeannie.github.io/gsDesign2_key_functions_inner_logic/articles/usage-gs-spending-bound.html","id":"examples","dir":"Articles","previous_headings":"","what":"Examples","title":"Computing spending boundaries in group sequential design","text":"Analogous gsDesign package, look 6 variations combinations efficacy futility bounds.","code":""},{"path":"https://littlebeannie.github.io/gsDesign2_key_functions_inner_logic/articles/usage-gs-spending-bound.html","id":"example-1-efficacy-bound-only","dir":"Articles","previous_headings":"Examples","what":"Example 1: Efficacy bound only","title":"Computing spending boundaries in group sequential design","text":"One-sided design efficacy bound. easy way use fixed bound (lower = gs_b) negative infinite bounds (lpar = rep(-Inf, 3)); summary table produced, infinite bounds appear. upper bound implements spending bound (upper = gs_spending_bound) list objects provided upar describe spending function associated parameters. parts upar list used sf = gsDesign::sfLDOF select Lan-DeMets spending function approximates O’Brien-Fleming bound. total_spend = alpha sets total spending targeted Type error study. upper bound provides Type error control design specified elsewhere. Now check gsDesign::gsSurv(). noted , sample size event counts vary slightly design derived using gs_design_ahr(). also results slightly different crossing probabilities alternate hypothesis interim analyses well slightly different approximate hazard ratios required cross bounds. Comparing Z-value bounds directly see approximately 6 digits precision parameters chosen (r=32, tol=1e-08):","code":"upar <- list(sf = gsDesign::sfLDOF, total_spend = alpha, param = NULL)  one_sided <- gsDesign2::gs_design_ahr(   enroll_rate = enroll_rate, fail_rate = fail_rate,   ratio = ratio, beta = beta,   # Information fraction at analyses and trial duration   info_frac = info_frac, analysis_time = trial_duration,   # Precision parameters for computations   r = 32, tol = 1e-08,   # Use NULL information for Type I error, H1 information for Type II error (power)   info_scale = \"h0_h1_info\", # Default   # Upper spending bound and corresponding parameter(s)   upper = gs_spending_bound, upar = upar,   # No lower bound   lower = gs_b, lpar = rep(-Inf, 3) )  one_sided |>   summary() |>   gsDesign2::as_gt(title = \"Efficacy bound only\", subtitle = \"alpha-spending\") oneSided <- gsSurv(   alpha = alpha, beta = beta, timing = info_frac, T = trial_duration, minfup = minfup,   lambdaC = fail_rate$fail_rate, eta = fail_rate$dropout_rate, hr = fail_rate$hr,   r = 32, tol = 1e-08, # Precision parameters for computations   test.type = 1, # One-sided bound; efficacy only   # Upper bound parameters   sfu = upar$sf, sfupar = upar$param, ) oneSided |> gsBoundSummary() #>     Analysis              Value Efficacy #>    IA 1: 35%                  Z   3.6128 #>       N: 356        p (1-sided)   0.0002 #>  Events: 100       ~HR at bound   0.4852 #>    Month: 14   P(Cross) if HR=1   0.0002 #>              P(Cross) if HR=0.7   0.0338 #>    IA 2: 70%                  Z   2.4406 #>       N: 394        p (1-sided)   0.0073 #>  Events: 200       ~HR at bound   0.7079 #>    Month: 23   P(Cross) if HR=1   0.0074 #>              P(Cross) if HR=0.7   0.5341 #>        Final                  Z   2.0002 #>       N: 394        p (1-sided)   0.0227 #>  Events: 286       ~HR at bound   0.7891 #>    Month: 36   P(Cross) if HR=1   0.0250 #>              P(Cross) if HR=0.7   0.8500 one_sided$bound$z - oneSided$upper$bound #> [1] -4.205166e-08  9.209740e-07  3.514498e-07"},{"path":"https://littlebeannie.github.io/gsDesign2_key_functions_inner_logic/articles/usage-gs-spending-bound.html","id":"example-2-symmetric-2-sided-design","dir":"Articles","previous_headings":"Examples","what":"Example 2: Symmetric 2-sided design","title":"Computing spending boundaries in group sequential design","text":"now derive symmetric 2-sided design. requires use argument h1_spending = FALSE use \\(\\alpha\\)-spending upper lower bounds. lower bound labeled futility bound table, better termed efficacy bound control better experimental treatment. compare gsDesign::gsSurv(). Comparing Z-value bounds directly, see approximately 6 digits accuracy.","code":"upar <- list(sf = gsDesign::sfLDOF, total_spend = alpha, param = NULL) lpar <- list(sf = gsDesign::sfLDOF, total_spend = alpha, param = NULL)  symmetric <- gs_design_ahr(   enroll_rate = enroll_rate, fail_rate = fail_rate,   ratio = ratio, beta = beta,   # Information fraction at analyses and trial duration   info_frac = info_frac, analysis_time = trial_duration,   # Precision parameters for computations   r = 32, tol = 1e-08,   # Use NULL information for Type I error, H1 information for power   info_scale = \"h0_h1_info\", # Default   # Function and parameter(s) for upper spending bound   upper = gs_spending_bound, upar = upar,   lower = gs_spending_bound, lpar = lpar,   # Symmetric designs use binding bounds   binding = TRUE,   h1_spending = FALSE # Use null hypothesis spending for lower bound )  symmetric |>   summary() |>   gsDesign2::as_gt(     title = \"2-sided Symmetric Design\",     subtitle = \"Single spending function\"   ) Symmetric <-   gsSurv(     test.type = 2, # Two-sided symmetric bound     alpha = alpha, beta = beta, timing = info_frac, T = trial_duration, minfup = minfup, r = 32, tol = 1e-08,     lambdaC = fail_rate$fail_rate, eta = fail_rate$dropout_rate, hr = fail_rate$hr,     sfu = upar$sf, sfupar = upar$param   ) Symmetric |> gsBoundSummary() #>     Analysis              Value Efficacy Futility #>    IA 1: 35%                  Z   3.6128  -3.6128 #>       N: 356        p (1-sided)   0.0002   0.0002 #>  Events: 100       ~HR at bound   0.4852   2.0609 #>    Month: 14   P(Cross) if HR=1   0.0002   0.0002 #>              P(Cross) if HR=0.7   0.0338   0.0000 #>    IA 2: 70%                  Z   2.4406  -2.4406 #>       N: 394        p (1-sided)   0.0073   0.0073 #>  Events: 200       ~HR at bound   0.7079   1.4126 #>    Month: 23   P(Cross) if HR=1   0.0074   0.0074 #>              P(Cross) if HR=0.7   0.5341   0.0000 #>        Final                  Z   2.0002  -2.0002 #>       N: 394        p (1-sided)   0.0227   0.0227 #>  Events: 286       ~HR at bound   0.7891   1.2673 #>    Month: 36   P(Cross) if HR=1   0.0250   0.0250 #>              P(Cross) if HR=0.7   0.8500   0.0000 dplyr::filter(symmetric$bound, bound == \"upper\")$z - Symmetric$upper$bound #> [1] -4.205166e-08  9.209740e-07  4.092129e-07 dplyr::filter(symmetric$bound, bound == \"lower\")$z - Symmetric$lower$bound #> [1]  4.205166e-08 -9.209740e-07 -4.092129e-07"},{"path":"https://littlebeannie.github.io/gsDesign2_key_functions_inner_logic/articles/usage-gs-spending-bound.html","id":"example-3-asymmetric-2-sided-design-with-beta-spending-and-binding-futility","dir":"Articles","previous_headings":"Examples","what":"Example 3: Asymmetric 2-sided design with \\(\\beta\\)-spending and binding futility","title":"Computing spending boundaries in group sequential design","text":"Designs binding futility bounds generally considered acceptable Phase 3 trials Type error controlled futility bound crossed trial continues, infrequent occurrence. binding futility bound means Type error computations assume trial stops futility bound crossed. trial continues futility bound crossed, Type error longer controlled computed efficacy bound. Phase 2b study, may acceptable results slightly smaller sample size less stringent efficacy bounds first analysis comparable design non-binding futility bound presented Example 4. compare gsDesign::gsSurv(). Comparing Z-value bounds directly, see approximately 6 digits accuracy spite needing relaxing accuracy tol = 1e-07 call gsSurv() order get convergence.","code":"upar <- list(sf = gsDesign::sfLDOF, total_spend = alpha, param = NULL) lpar <- list(sf = gsDesign::sfHSD, total_spend = beta, param = -.5)  asymmetric_binding <- gs_design_ahr(   enroll_rate = enroll_rate, fail_rate = fail_rate,   ratio = ratio, beta = beta,   # Information fraction at analyses and trial duration   info_frac = info_frac, analysis_time = trial_duration,   # Precision parameters for computations   r = 32, tol = 1e-08,   # Use NULL information for Type I error, H1 information for Type II error and power   info_scale = \"h0_h1_info\",   # Function and parameter(s) for upper spending bound   upper = gs_spending_bound, upar = upar,   lower = gs_spending_bound, lpar = lpar,   # Asymmetric beta-spending design using binding bounds   binding = TRUE,   h1_spending = TRUE # Use beta-spending for futility )  asymmetric_binding |>   summary() |>   gsDesign2::as_gt(     title = \"2-sided asymmetric design with binding futility\",     subtitle = \"Both alpha- and beta-spending used\"   ) asymmetricBinding <- gsSurv(   test.type = 3, # Two-sided asymmetric bound, binding futility   alpha = alpha, beta = beta, timing = info_frac, T = trial_duration, minfup = minfup, r = 32, tol = 1e-07,   lambdaC = fail_rate$fail_rate, eta = fail_rate$dropout_rate, hr = fail_rate$hr,   sfu = upar$sf, sfupar = upar$param, sfl = lpar$sf, sflpar = lpar$param ) asymmetricBinding |> gsBoundSummary() #>     Analysis              Value Efficacy Futility #>    IA 1: 35%                  Z   3.6128   0.1436 #>       N: 380        p (1-sided)   0.0002   0.4429 #>  Events: 107       ~HR at bound   0.4971   0.9726 #>    Month: 14   P(Cross) if HR=1   0.0002   0.5571 #>              P(Cross) if HR=0.7   0.0387   0.0442 #>    IA 2: 70%                  Z   2.4382   1.1807 #>       N: 422        p (1-sided)   0.0074   0.1189 #>  Events: 214       ~HR at bound   0.7164   0.8509 #>    Month: 23   P(Cross) if HR=1   0.0074   0.8913 #>              P(Cross) if HR=0.7   0.5679   0.0969 #>        Final                  Z   1.9232   1.9232 #>       N: 422        p (1-sided)   0.0272   0.0272 #>  Events: 306       ~HR at bound   0.8024   0.8024 #>    Month: 36   P(Cross) if HR=1   0.0250   0.9750 #>              P(Cross) if HR=0.7   0.8500   0.1500 dplyr::filter(asymmetric_binding$bound, bound == \"upper\")$z - asymmetricBinding$upper$bound #> [1] -4.205166e-08  2.505875e-04  6.494368e-03 dplyr::filter(asymmetric_binding$bound, bound == \"lower\")$z - asymmetricBinding$lower$bound #> [1] -0.02803422 -0.02670907 -0.01598640"},{"path":"https://littlebeannie.github.io/gsDesign2_key_functions_inner_logic/articles/usage-gs-spending-bound.html","id":"example-4-asymmetric-2-sided-design-with-beta-spending-and-non-binding-futility-bound","dir":"Articles","previous_headings":"Examples","what":"Example 4: Asymmetric 2-sided design with \\(\\beta\\)-spending and non-binding futility bound","title":"Computing spending boundaries in group sequential design","text":"gsDesign package, asymmetric designs non-binding \\(\\beta\\)-spending used futility default design. objectives type design include: Meaningful futility bounds stop trial early treatment benefit emerging experimental treatment vs. control. Type error controlled even trial continues futility bound crossed. compare gsDesign::gsSurv(). Comparing Z-value bounds directly, see approximately 6 digits accuracy.","code":"upar <- list(sf = gsDesign::sfLDOF, total_spend = alpha, param = NULL) lpar <- list(sf = gsDesign::sfHSD, total_spend = beta, param = -.5)  asymmetric_nonbinding <- gs_design_ahr(   enroll_rate = enroll_rate, fail_rate = fail_rate,   ratio = ratio, beta = beta,   # Information fraction at analyses and trial duration   info_frac = info_frac, analysis_time = trial_duration,   # Precision parameters for computations   r = 32, tol = 1e-08,   # Use NULL information for Type I error, H1 info for Type II error and power   info_scale = \"h0_h1_info\", # Default   # Function and parameter(s) for upper spending bound   upper = gs_spending_bound, upar = upar,   lower = gs_spending_bound, lpar = lpar,   # Asymmetric beta-spending design use binding bounds   binding = FALSE,   h1_spending = TRUE # Use beta-spending for futility )  asymmetric_nonbinding |>   summary() |>   gsDesign2::as_gt(     title = \"2-sided asymmetric design with non-binding futility\",     subtitle = \"Both alpha- and beta-spending used\"   ) asymmetricNonBinding <- gsSurv(   test.type = 4, # Two-sided asymmetric bound, non-binding futility   alpha = alpha, beta = beta, timing = info_frac, T = trial_duration, minfup = minfup, r = 32, tol = 1e-08,   lambdaC = fail_rate$fail_rate, eta = fail_rate$dropout_rate, hr = fail_rate$hr,   sfu = upar$sf, sfupar = upar$param, sfl = lpar$sf, sflpar = lpar$param ) asymmetricNonBinding |> gsBoundSummary() #>     Analysis              Value Efficacy Futility #>    IA 1: 35%                  Z   3.6128   0.1860 #>       N: 398        p (1-sided)   0.0002   0.4262 #>  Events: 112       ~HR at bound   0.5050   0.9654 #>    Month: 14   P(Cross) if HR=1   0.0002   0.5738 #>              P(Cross) if HR=0.7   0.0424   0.0442 #>    IA 2: 70%                  Z   2.4406   1.2406 #>       N: 440        p (1-sided)   0.0073   0.1074 #>  Events: 224       ~HR at bound   0.7215   0.8471 #>    Month: 23   P(Cross) if HR=1   0.0073   0.9020 #>              P(Cross) if HR=0.7   0.5901   0.0969 #>        Final                  Z   2.0002   2.0002 #>       N: 440        p (1-sided)   0.0227   0.0227 #>  Events: 320       ~HR at bound   0.7995   0.7995 #>    Month: 36   P(Cross) if HR=1   0.0215   0.9785 #>              P(Cross) if HR=0.7   0.8500   0.1500 dplyr::filter(asymmetric_nonbinding$bound, bound == \"upper\")$z - asymmetricNonBinding$upper$bound #> [1] -4.205166e-08  9.209740e-07  3.514498e-07 dplyr::filter(asymmetric_nonbinding$bound, bound == \"lower\")$z - asymmetricNonBinding$lower$bound #> [1] -0.03267437 -0.03311078 -0.02426999"},{"path":"https://littlebeannie.github.io/gsDesign2_key_functions_inner_logic/articles/usage-gs-spending-bound.html","id":"example-5-asymmetric-2-sided-design-with-null-hypothesis-spending-and-binding-futility-bound","dir":"Articles","previous_headings":"Examples","what":"Example 5: Asymmetric 2-sided design with null hypothesis spending and binding futility bound","title":"Computing spending boundaries in group sequential design","text":"Now use null hypothesis probabilities set futility bounds. parameter alpha_star used set total spending futility bound null hypothesis. example, set 0.5 50% probability crossing futility bound interim final analyses combined. futility bound final analysis really role, use test_lower argument eliminate evaluation final analysis. arbitrary largely selected interim futility bounds can meaningful tests. case, minor trend favor control first second interim cross futility bound. less stringent \\(\\beta\\)-spending bounds previously described, still address potential ethical issue continuing trial minor trend favor control present. Comparing Z-value bounds directly, see approximately 6 digits accuracy. gsSurv() require alternate arguments r tol.","code":"alpha_star <- .5 upar <- list(sf = gsDesign::sfLDOF, total_spend = alpha, param = NULL) lpar <- list(sf = gsDesign::sfHSD, total_spend = alpha_star, param = 1)  asymmetric_safety_binding <- gs_design_ahr(   enroll_rate = enroll_rate, fail_rate = fail_rate,   ratio = ratio, beta = beta,   # Information fraction at analyses and trial duration   info_frac = info_frac, analysis_time = trial_duration,   # Precision parameters for computations   r = 32, tol = 1e-08,   # Use NULL information for Type I error, H1 information for Type II error   info_scale = \"h0_info\",   # Function and parameter(s) for upper spending bound   upper = gs_spending_bound, upar = upar,   lower = gs_spending_bound, lpar = lpar,   test_lower = c(TRUE, TRUE, FALSE),   # Asymmetric design use binding bounds   binding = TRUE,   h1_spending = FALSE # Use null-spending for futility )  asymmetric_safety_binding |>   summary() |>   gsDesign2::as_gt(     title = \"2-sided asymmetric safety design with binding futility\",     subtitle = \"Alpha-spending used for both bounds, asymmetrically\"   ) asymmetricSafetyBinding <- gsSurv(   test.type = 5, # Two-sided asymmetric bound, binding futility, H0 futility spending   astar = alpha_star, # Total Type I error spend for futility   alpha = alpha, beta = beta, timing = info_frac, T = trial_duration, minfup = minfup,   lambdaC = fail_rate$fail_rate, eta = fail_rate$dropout_rate, hr = fail_rate$hr,   sfu = upar$sf, sfupar = upar$param, sfl = lpar$sf, sflpar = lpar$param ) asymmetricSafetyBinding |> gsBoundSummary() #>     Analysis              Value Efficacy Futility #>    IA 1: 35%                  Z   3.6128  -0.7271 #>       N: 356        p (1-sided)   0.0002   0.7664 #>  Events: 101       ~HR at bound   0.4856   1.1565 #>    Month: 14   P(Cross) if HR=1   0.0002   0.2336 #>              P(Cross) if HR=0.7   0.0340   0.0060 #>    IA 2: 70%                  Z   2.4405  -0.4203 #>       N: 394        p (1-sided)   0.0073   0.6629 #>  Events: 201       ~HR at bound   0.7082   1.0612 #>    Month: 23   P(Cross) if HR=1   0.0074   0.3982 #>              P(Cross) if HR=0.7   0.5353   0.0070 #>        Final                  Z   1.9979  -0.2531 #>       N: 394        p (1-sided)   0.0229   0.5999 #>  Events: 286       ~HR at bound   0.7895   1.0304 #>    Month: 36   P(Cross) if HR=1   0.0250   0.5000 #>              P(Cross) if HR=0.7   0.8500   0.0072 dplyr::filter(asymmetric_safety_binding$bound, bound == \"upper\")$z - asymmetricSafetyBinding$upper$bound #> [1] -4.205166e-08  9.202022e-07  4.182939e-07 dplyr::filter(asymmetric_safety_binding$bound, bound == \"lower\")$z - asymmetricSafetyBinding$lower$bound[1:2] #> [1]  1.355437e-08 -2.804509e-08"},{"path":"https://littlebeannie.github.io/gsDesign2_key_functions_inner_logic/articles/usage-gs-spending-bound.html","id":"example-6-asymmetric-2-sided-design-with-null-hypothesis-spending-and-non-binding-futility-bound","dir":"Articles","previous_headings":"Examples","what":"Example 6: Asymmetric 2-sided design with null hypothesis spending and non-binding futility bound","title":"Computing spending boundaries in group sequential design","text":", recommend non-binding bound presented binding bound example 5. eliminate final futility bound using test_lower argument. Addition, show eliminate efficacy bound interim 1 allowing team decide early stop trial efficacy without longer-term data. corresponding gsDesign::gsSurv() design strictly comparable since option eliminate futility efficacy analyses enabled.","code":"upar <- list(sf = gsDesign::sfLDOF, total_spend = alpha, param = NULL) lpar <- list(sf = gsDesign::sfHSD, total_spend = alpha_star, param = 1)  asymmetric_safety_nonbinding <- gs_design_ahr(   enroll_rate = enroll_rate, fail_rate = fail_rate,   ratio = ratio, beta = beta,   # Information fraction at analyses and trial duration   info_frac = info_frac, analysis_time = trial_duration,   # Precision parameters for computations   r = 32, tol = 1e-08,   # Use NULL information for Type I error, H1 information for Type II error   info_scale = \"h0_info\",   # Function and parameter(s) for upper spending bound   upper = gs_spending_bound, upar = upar,   test_upper = c(FALSE, TRUE, TRUE),   lower = gs_spending_bound, lpar = lpar,   test_lower = c(TRUE, TRUE, FALSE),   # Asymmetric design use non-binding bounds   binding = FALSE,   h1_spending = FALSE # Use null-spending for futility ) |> to_integer()  asymmetric_safety_nonbinding |>   summary() |>   gsDesign2::as_gt(     title = \"2-sided asymmetric safety design with non-binding futility\",     subtitle = \"Alpha-spending used for both bounds, asymmetrically\"   ) |>   gt::tab_footnote(footnote = \"Integer-based sample size and event counts\") asymmetricSafetyNonBinding <- gsSurv(   test.type = 6, # Two-sided asymmetric bound, binding futility, H0 futility spending   astar = alpha_star, # Total Type I error spend for futility   alpha = alpha, beta = beta, timing = info_frac, T = trial_duration, minfup = minfup, r = 32, tol = 1e-08,   lambdaC = fail_rate$fail_rate, eta = fail_rate$dropout_rate, hr = fail_rate$hr,   sfu = upar$sf, sfupar = upar$param, sfl = lpar$sf, sflpar = lpar$param ) asymmetricSafetyBinding |> gsBoundSummary() #>     Analysis              Value Efficacy Futility #>    IA 1: 35%                  Z   3.6128  -0.7271 #>       N: 356        p (1-sided)   0.0002   0.7664 #>  Events: 101       ~HR at bound   0.4856   1.1565 #>    Month: 14   P(Cross) if HR=1   0.0002   0.2336 #>              P(Cross) if HR=0.7   0.0340   0.0060 #>    IA 2: 70%                  Z   2.4405  -0.4203 #>       N: 394        p (1-sided)   0.0073   0.6629 #>  Events: 201       ~HR at bound   0.7082   1.0612 #>    Month: 23   P(Cross) if HR=1   0.0074   0.3982 #>              P(Cross) if HR=0.7   0.5353   0.0070 #>        Final                  Z   1.9979  -0.2531 #>       N: 394        p (1-sided)   0.0229   0.5999 #>  Events: 286       ~HR at bound   0.7895   1.0304 #>    Month: 36   P(Cross) if HR=1   0.0250   0.5000 #>              P(Cross) if HR=0.7   0.8500   0.0072"},{"path":"https://littlebeannie.github.io/gsDesign2_key_functions_inner_logic/articles/usage-gs-spending-bound.html","id":"example-7-alternate-bound-types","dir":"Articles","previous_headings":"Examples","what":"Example 7: Alternate bound types","title":"Computing spending boundaries in group sequential design","text":"consider two types alternative boundary computation approaches. Computing futility bounds based hazard ratio. Computing efficacy bounds Haybittle-Peto related Fleming-Harrington-O’Brien approach. begin futility bound. consider non-binding futility bound impact efficacy bound. Assume clinical trial team wishes stop trial first two interim analyses targeted interim hazard ratio achieved. approach can require bit iteration (trial error) incorporate final design endpoint count; skip iteration . assume wish consider stopping futility hazard ratio greater 1 0.9 observed interim analyses 1 2 104 209 events observed, respectively. final analysis planned 300 events. wish translate hazard ratios specified corresponding Z-values; can done follows. add final futility bound -Inf, indicating final futility analysis; gives us vector Z-value bounds analyses. type bound, Type II error computed rather based bounds rather spending approach bounds computed based specified spending. efficacy bound, first consider Haybittle-Peto fixed bound interim analyses. Using Bonferroni approach, test nominal levels 0.001, 0.001, 0.023 3 analyses. accounting correlations, actually quite use 0.025 1-sided Type error allowed. allow user substitute code follows verify . alternative approach use fixed spending approach analysis suggested (fleming1984designs?). , iteration shown, use piecewise linear spending function select interim bounds match desired Haybittle-Peto interim bounds. However, using approach slightly liberal final bound achieved still controls Type error. see targeted bounds achieved nominal \\(p\\)-values 0.0001 interim efficacy bound targeted hazard ratios interim futility bounds. methods, trial designers control design characteristics may desire. particular, note Haybittle-Peto efficacy bounds less stringent first interim stringent second interim corresponding O’Brien-Fleming-like bounds computed spending approach. may may desirable.","code":"# Targeted events at interim and final analysis # This is based on above designs and then adjusted, as necessary targeted_events <- c(104, 209, 300) interim_futility_z <- -gsDesign::hrn2z(hr = c(1, .9), n = targeted_events[1:2]) interim_futility_z #> [1] 0.0000000 0.7615897 lower <- gs_b # Allows specifying fixed Z-values for futility # Translated HR bounds to Z-value scale lpar <- c(interim_futility_z, -Inf) upper <- gs_b upar <- qnorm(c(.001, .001, .0023), lower.tail = FALSE) upper <- gs_spending_bound upar <- list(   sf = gsDesign::sfLinear,   total_spend = alpha,   param = c(targeted_events[1:2] / targeted_events[3], c(.001, .0018) / .025),   timing = NULL )  asymmetric_fixed_bounds <- gs_design_ahr(   enroll_rate = enroll_rate, fail_rate = fail_rate,   ratio = ratio, beta = beta,   # Information fraction at analyses and trial duration   info_frac = info_frac, analysis_time = trial_duration,   # Precision parameters for computations   r = 32, tol = 1e-08,   # Use NULL information for Type I error, H1 information for Type II error   info_scale = \"h0_info\",   # Function and parameter(s) for upper spending bound   upper = upper, upar = upar,   lower = lower, lpar = lpar,   # Non-binding futility bounds   binding = FALSE ) |> to_integer()  asymmetric_fixed_bounds |>   summary() |>   gsDesign2::as_gt(     title = \"2-sided asymmetric safety design with fixed non-binding futility\",     subtitle = \"Futility bounds computed to approximate HR\"   ) |>   gt::tab_footnote(footnote = \"Integer-based sample size and event counts\")"},{"path":[]},{"path":"https://littlebeannie.github.io/gsDesign2_key_functions_inner_logic/articles/usage-summary-as-gt.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"summary & as_gt: summarize group sequential design","text":"vignette introduces publication quality table production group sequential designs gsDesign2 package. also demonstrates designs example scenario using multiple design approaches. divide document 3 parts: Design specification derivation Printing design summary tables Details output design functions Details table output options reader can decide sections interest . function used generate bounds tables gsDesign2::summary(). Users can use gsDesign2::as_gt() format table using gt package. vignette, introduce general approach bound summaries examples using different design approaches time--event outcome: average hazard ratio (AHR) method extended (mukhopadhyay2020statistical?) using gsDesign2::gs_design_ahr(); weighted logrank (WLR) method (yung2020sample?) using gsDesign2::gs_design_wlr();","code":""},{"path":[]},{"path":"https://littlebeannie.github.io/gsDesign2_key_functions_inner_logic/articles/usage-summary-as-gt.html","id":"design-parameters","dir":"Articles","previous_headings":"Design specification and derivation","what":"Design parameters","title":"summary & as_gt: summarize group sequential design","text":"design parameters use across different designs derived :","code":"# enrollment/failure rates enroll_rate <- define_enroll_rate(   duration = 12,   rate = 1 )  fail_rate <- define_fail_rate(   duration = c(4, 100),   fail_rate = log(2) / 12,   hr = c(1, .6),   dropout_rate = .001 )  # Information fraction info_frac <- (1:3) / 3 # Analysis times in months; first 2 will be ignored as IF will not be achieved analysis_time <- c(.01, .02, 36)  # Experimental / Control randomization ratio ratio <- 1  # 1-sided Type I error alpha <- 0.025 # Type II error (1 - power) beta <- 0.1  # Upper bound upper <- gsDesign2::gs_spending_bound # alpha-spending bound upar <- list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL)  # Lower bound lower <- gsDesign2::gs_spending_bound # beta-spending bound lpar <- list(sf = gsDesign::sfHSD, total_spend = 0.1, param = 0, timing = NULL)  # Fleming-Harrington (FH) weight functions for weighted logrank (WLR) wgt00 <- function(x, arm0, arm1) { # Equal weighting for logrank   wlr_weight_fh(x, arm0, arm1, rho = 0, gamma = 0) } wgt05 <- function(x, arm0, arm1) { # Early downweighting with FH(0,.5)   wlr_weight_fh(x, arm0, arm1, rho = 0, gamma = .5) }  # Both of above tests for MaxCombo: logrank and FH(0,.5) fh_test <- rbind(   # Include logrank for all 3 analyses   data.frame(rho = 0, gamma = 0, tau = -1, test = 1, Analysis = 1:3, analysis_time = c(12, 24, 36)),   # Only include FH(0,.5) for analyses 2 and 3   data.frame(rho = c(0, 0.5), gamma = 0.5, tau = -1, test = 2:3, Analysis = 3, analysis_time = 36) )"},{"path":[]},{"path":"https://littlebeannie.github.io/gsDesign2_key_functions_inner_logic/articles/usage-summary-as-gt.html","id":"ahr-design-derivation","dir":"Articles","previous_headings":"Design specification and derivation > Deriving designs","what":"AHR design derivation","title":"summary & as_gt: summarize group sequential design","text":"Using design parameters , AHR design derived follows: using design parameters , one can generate AHR model gs_design_ahr ","code":"x_design_ahr <- gs_design_ahr(   enroll_rate = enroll_rate,   fail_rate = fail_rate,   info_frac = info_frac,   analysis_time = analysis_time,   ratio = ratio,   alpha = alpha,   beta = beta,   upper = upper,   upar = upar,   lower = lower,   lpar = lpar )  x_power_ahr <- gs_power_ahr(   enroll_rate = x_design_ahr$enroll_rate,   fail_rate = x_design_ahr$fail_rate,   event = c(100, 200, 400),   analysis_time = NULL,   upper = upper,   upar = upar,   lower = lower,   lpar = lpar )"},{"path":"https://littlebeannie.github.io/gsDesign2_key_functions_inner_logic/articles/usage-summary-as-gt.html","id":"wlr-design-derivation","dir":"Articles","previous_headings":"Design specification and derivation > Deriving designs","what":"WLR design derivation","title":"summary & as_gt: summarize group sequential design","text":"","code":"x_design_wlr <- gs_design_wlr(   enroll_rate = enroll_rate,   fail_rate = fail_rate,   weight = wgt05,   info_frac = NULL,   analysis_time = sort(unique(x_design_ahr$analysis$time)),   ratio = ratio,   alpha = alpha,   beta = beta,   upper = upper,   upar = upar,   lower = lower,   lpar = lpar )"},{"path":"https://littlebeannie.github.io/gsDesign2_key_functions_inner_logic/articles/usage-summary-as-gt.html","id":"default-summary-table-production","dir":"Articles","previous_headings":"","what":"Default summary table production","title":"summary & as_gt: summarize group sequential design","text":"Instead outputting 4 detailed tables (table enrollment rates, table failure rates, table analysis summary, table bounds summary), users can get com pensive summary table calling summary(x), x object returned either gs_design_ahr gs_design_wlr. summary() function produces overall summary table bounds publication protocol. example, default output summary() AHR method Please note summary() can also applied objected returned gs_power_ahr(). example, default output summary() WLR method ","code":"x_design_ahr %>%   summary() %>%   gt::gt() %>%   gt::fmt_number(columns = c(3:6), decimals = 4) x_power_ahr %>%   summary() %>%   gt::gt() %>%   gt::fmt_number(columns = c(3:6), decimals = 4) x_design_wlr %>%   summary() %>%   gt::gt() %>%   gt::fmt_number(columns = c(3:6), decimals = 4)"},{"path":"https://littlebeannie.github.io/gsDesign2_key_functions_inner_logic/articles/usage-summary-as-gt.html","id":"detailed-summary-table-formatting","dir":"Articles","previous_headings":"","what":"Detailed summary table formatting","title":"summary & as_gt: summarize group sequential design","text":"demonstrate options formatting analysis rows, bound rows well table parameters titles, labels footnotes.","code":""},{"path":"https://littlebeannie.github.io/gsDesign2_key_functions_inner_logic/articles/usage-summary-as-gt.html","id":"customize-the-variables-to-be-summarized-for-each-analysis","dir":"Articles","previous_headings":"Detailed summary table formatting","what":"Customize the variables to be summarized for each analysis","title":"summary & as_gt: summarize group sequential design","text":"default table summary table generated summary(x), variables used summarize analysis includes Analysis, Time, N(sample size), Events, AHR, (information fraction). users can customize variables chosen using analysis_vars = ... corresponding decimals displayed using argument analysis_decimals = .... example Please note need input \"Analysis\" analysis_vars = ... always appear.","code":"x_design_ahr %>%   summary(     analysis_vars = c(\"n\", \"event\"),     analysis_decimals = c(1, 1)   ) %>%   gt::gt() %>%   gt::fmt_number(columns = c(3:6), decimals = 4)"},{"path":"https://littlebeannie.github.io/gsDesign2_key_functions_inner_logic/articles/usage-summary-as-gt.html","id":"customize-the-bound-names","dir":"Articles","previous_headings":"Detailed summary table formatting","what":"Customize the bound names","title":"summary & as_gt: summarize group sequential design","text":"Users can also customize bound names. default output generated summary(x), bound name c(\"Efficacy\", \"Futility\"), can changed c(\"better\", \"B better\") 2-sided design using argument bound_names = .... example,","code":"x_design_ahr %>%   summary(bound_names = c(\"A is better\", \"B is better\")) %>%   mutate_if(is.numeric, round, digits = 4) %>%   gt::gt() %>%   gt::fmt_number(columns = c(3:6), decimals = 4)"},{"path":"https://littlebeannie.github.io/gsDesign2_key_functions_inner_logic/articles/usage-summary-as-gt.html","id":"custom-into-a-gt-table-and-add-titlesubtitlefootnotesspanners","dir":"Articles","previous_headings":"Detailed summary table formatting","what":"Custom into a gt table and add title/subtitle/footnotes/spanners","title":"summary & as_gt: summarize group sequential design","text":"Users can also use as_gt() get R table gt table. Furthermore, can edit title/subtitle/spanner/footnotes gt table using arguments summary. objective can also realized using functions R package gt custom design table layout. note as_gt() always produces gt object , thus, can customized gt package formatting functions. future, support rich text format using function as_rtf() fashion similar as_gt().","code":"summary(x_design_ahr) %>%   as_gt(     title = \"Summary of the Crossing Probability\",     subtitle = \"by Using gs_design_ahr\",     colname_spanner = \"Cumulative boundary crossing probability\",     colname_spannersub = c(\"Alternate hypothesis\", \"Null hypothesis\"),     footnote = list(       content = c(         \"approximate hazard ratio to cross bound.\",         \"gs_design_ahr is a function in gsDesign2.\",         \"AHR is average hazard ratio; IF is information fraction.\"       ),       location = c(\"~HR at bound\", NA, NA),       attr = c(\"colname\", \"subtitle\", \"analysis\")     )   )"},{"path":"https://littlebeannie.github.io/gsDesign2_key_functions_inner_logic/articles/usage-summary-as-gt.html","id":"customize-the-variables-to-display","dir":"Articles","previous_headings":"Detailed summary table formatting","what":"Customize the variables to display","title":"summary & as_gt: summarize group sequential design","text":"Users can select variables displayed summary table using argument display_colunm = ....","code":"x_design_ahr %>%   summary() %>%   as_gt(display_columns = c(\"Analysis\", \"Bound\", \"Z\", \"Probability\"))"},{"path":"https://littlebeannie.github.io/gsDesign2_key_functions_inner_logic/articles/usage-summary-as-gt.html","id":"customize-whether-to-show-infinity-bound-or-not","dir":"Articles","previous_headings":"Detailed summary table formatting","what":"Customize whether to show infinity bound or not","title":"summary & as_gt: summarize group sequential design","text":"Users options either show infinity bounds taking advantage display_inf_bound = ....","code":"x_design_ahr %>%   summary() %>%   as_gt(display_inf_bound = FALSE)"},{"path":"https://littlebeannie.github.io/gsDesign2_key_functions_inner_logic/articles/usage-summary-as-gt.html","id":"details-of-output-from-designpower-functions","dir":"Articles","previous_headings":"","what":"Details of output from design/power functions","title":"summary & as_gt: summarize group sequential design","text":"four components objects returned either gs_design_ahr()/gs_design_wlr() gs_power_ahr()/gs_power_wlr(): failure rates: table summarizing failure rate dropout rate. enrollment rates: table summarizing enrollment rate. bounds: table summarize bound analysis. analysis: table summarize analysis, one row one analysis one hypothesis.","code":""},{"path":"https://littlebeannie.github.io/gsDesign2_key_functions_inner_logic/articles/usage-summary-as-gt.html","id":"failure-rates","dir":"Articles","previous_headings":"Details of output from design/power functions","what":"Failure rates","title":"summary & as_gt: summarize group sequential design","text":"failure rates different gsDesign object can obtained using x$fail_rate, x object returned either gs_design_ahr gs_design_wlr. example, failure rates AHR design derivation can returned calling Please note x_design_ahr x_wlr returns failure rates, inputted fail_rate. verify, let’s take look failure rate WLR design derivation, shown .","code":"x_design_ahr$fail_rate %>%   gt::gt() %>%   gt::fmt_number(columns = 3:5, decimals = 4) x_design_wlr$fail_rate %>%   gt::gt() %>%   gt::fmt_number(columns = 3:5, decimals = 4)"},{"path":"https://littlebeannie.github.io/gsDesign2_key_functions_inner_logic/articles/usage-summary-as-gt.html","id":"enrollment","dir":"Articles","previous_headings":"Details of output from design/power functions","what":"Enrollment","title":"summary & as_gt: summarize group sequential design","text":"enrollment rate gs design derivation can collected using x$fail_rate, x object returned either gs_design_ahr gs_design_wlr. example, enrollment rates AHR/WLR design derivation can seen , although design derivation different, enrollment rate table share table structure, enrollment period durations rate. Yet, enrollment rates differ designs multiplicative constant.","code":"x_design_ahr$enroll_rate %>%   gt::gt() %>%   gt::fmt_number(columns = 3, decimals = 4) x_design_wlr$enroll_rate %>%   gt::gt() %>%   gt::fmt_number(columns = 3, decimals = 4)"},{"path":"https://littlebeannie.github.io/gsDesign2_key_functions_inner_logic/articles/usage-summary-as-gt.html","id":"analysis","dir":"Articles","previous_headings":"Details of output from design/power functions","what":"Analysis","title":"summary & as_gt: summarize group sequential design","text":"analysis summary table structure one row per analysis per hypothesis. columns can vary different defaults design option. type tables useful understanding commonalities designs summarized different models. get analysis summary table, users can call x$analysis, x object returned either gs_design_ahr gs_design_wlr. example, analysis summary AHR/WLR design derivation ","code":"x_design_ahr$analysis %>%   gt::gt() %>%   gt::fmt_number(columns = 2:8, decimals = 4) x_design_wlr$analysis %>%   gt::gt() %>%   gt::fmt_number(columns = 2:8, decimals = 4)"},{"path":"https://littlebeannie.github.io/gsDesign2_key_functions_inner_logic/articles/usage-summary-as-gt.html","id":"bounds","dir":"Articles","previous_headings":"Details of output from design/power functions","what":"Bounds","title":"summary & as_gt: summarize group sequential design","text":"analysis summary table structure One row per analysis per bound per hypothesis. Columns can vary different defaults design option. get bonus summary table, users can call x$analysis, x object returned either gs_design_ahr gs_design_wlr. example, bounds summary AHR/WLR design derivation ","code":"x_design_ahr$bound %>%   gt::gt() %>%   gt::fmt_number(columns = c(3, 5:7), decimals = 4) x_design_wlr$bound %>%   gt::gt() %>%   gt::fmt_number(columns = c(3, 5:7), decimals = 4)"},{"path":[]},{"path":"https://littlebeannie.github.io/gsDesign2_key_functions_inner_logic/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Yujie Zhao. Author, maintainer.","code":""},{"path":"https://littlebeannie.github.io/gsDesign2_key_functions_inner_logic/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Zhao Y (2024). gsDesign2KeyFunctionsInnerLogic: Explain internal programming logic key functions gsDesign2. R package version 1.0.0, https://littlebeannie.github.io/gsDesign2_key_functions_inner_logic/.","code":"@Manual{,   title = {gsDesign2KeyFunctionsInnerLogic: Explain the internal programming logic of key functions of gsDesign2},   author = {Yujie Zhao},   year = {2024},   note = {R package version 1.0.0},   url = {https://littlebeannie.github.io/gsDesign2_key_functions_inner_logic/}, }"},{"path":"https://littlebeannie.github.io/gsDesign2_key_functions_inner_logic/index.html","id":"gsdesign2_key_functions_inner_logic","dir":"","previous_headings":"","what":"Explain the internal programming logic of key functions of gsDesign2","title":"Explain the internal programming logic of key functions of gsDesign2","text":"Explain internal programming logic key functions gsDesign2","code":""}]
